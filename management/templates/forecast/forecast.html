{% extends "layout/app_base.html" %}
{% load static %}
{% block title %}Liquidity Forecast{% endblock %}

{% block extra_head %}
{{ block.super }}
<style>
  .forecast-page {
    --fc-line: #e5edf6;
    --fc-panel: #ffffff;
    --fc-muted: #475569;
    --fc-shadow: 0 4px 12px rgba(15, 23, 42, .04);
  }

  .forecast-page .panel {
    background: var(--fc-panel);
    border: 1px solid var(--fc-line);
    border-radius: 12px;
    padding: 16px 18px 20px;
    box-shadow: var(--fc-shadow);
    margin-bottom: 18px;
  }

  .forecast-page .block-heading {
    font-size: 15px;
    font-weight: 600;
    color: #0f172a;
    margin-bottom: 6px;
  }

  .forecast-page .block-sub {
    font-size: 13px;
    color: var(--fc-muted);
    line-height: 1.6;
    margin-bottom: 18px;
  }

  .forecast-page .chart-grid {
    display: grid;
    gap: 16px;
  }

  .forecast-page .chart-grid.two {
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr))
  }

  .forecast-page .chart-grid.single {
    grid-template-columns: 1fr
  }

  .forecast-page .chart-grid.quad {
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr))
  }

  .forecast-page .chart-card {
    border: 1px solid var(--fc-line);
    border-radius: 7px;
    padding: 12px;
  }

  .forecast-page .chart-card header {
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 8px;
    display: flex;
    justify-content: space-between;
    color: #0f172a;
  }

  .forecast-page .chart-card .small {
    font-size: 11px;
    color: var(--fc-muted)
  }

  .forecast-page svg {
    max-width: 100%
  }
  svg-wrap {
    margin: 134px;
    margin-top: 10px;
  }

  .empty-state {
    display: flex;
    align-items: center;
    gap: 14px;
    padding: 18px;
    border: 1px dashed #d6deee;
    border-radius: 12px;
    background: #f8fafc;
    color: #475569;
  }
  .empty-state__icon {
    width: 38px;
    height: 38px;
    border-radius: 12px;
    background: linear-gradient(135deg, #dbeafe, #f8fafc);
    box-shadow: inset 0 0 0 1px #dbeafe;
  }
  .empty-state__title {
    font-size: 14px;
    font-weight: 600;
    color: #0f172a;
    margin-bottom: 4px;
  }
  .empty-state__message {
    font-size: 12px;
    line-height: 1.5;
  }
  .empty-state__action {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    margin-top: 10px;
    padding: 6px 12px;
    border-radius: 999px;
    border: 1px solid #d7e0f5;
    background: #fff;
    color: #1e3a8a;
    font-size: 12px;
    font-weight: 600;
    text-decoration: none;
  }
  .empty-state__skeleton span {
    display: block;
    height: 8px;
    border-radius: 999px;
    background: linear-gradient(90deg, #e2e8f0, #f8fafc, #e2e8f0);
    background-size: 200% 100%;
    animation: empty-shimmer 1.5s ease-in-out infinite;
    margin-top: 8px;
    width: 220px;
  }
  .empty-state__skeleton span:nth-child(2) {
    width: 180px;
  }
  .empty-state__skeleton span:nth-child(3) {
    width: 140px;
  }
  @keyframes empty-shimmer {
    0% { background-position: 0% 50%; }
    100% { background-position: 200% 50%; }
  }
  .chart-card .empty-state {
    min-height: 200px;
  }
  .chart-card.chart-big .empty-state {
    min-height: 240px;
  }
  .forecast-empty {
    margin-top: 16px;
    padding: 12px;
  }
</style>
{% endblock %}

{% block page_content %}
{% url "admin_component" "snapshotSummaries" as admin_snapshot_url %}
{% url "admin_component" "forecast" as admin_forecast_url %}
<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Forecast Dashboard (Static)</title>
  <style>
    .snapshot-card {
      background: #fff;
      padding: 10px 12px;
      border-radius: 10px;
    }

    .snapshot-head {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .snapshot-icon {
      width: 14px;
      height: 14px;
      display: block;
    }

    .snapshot-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 17px;
      font-weight: 600;
      color: #102048;
      /* dark heading */
    }

    .snapshot-title .dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #2563eb;
      /* blue dot */
      display: inline-block;
    }

    .snapshot-text {
    margin: 6px;
    font-size: 15px;
    line-height: 1.4;
    color: #6b7280;
}

    .forecast-shell {
      --bg: #f4f7fb;
      --card: #ffffff;
      --ink: #101828;
      --muted: #667085;
      --muted2: #98A2B3;
      --border: #E6EAF2;
      --grid: #EEF2F7;
      --blue: #0753B2;
      --orange: #FC912E;
      --shadow: 0 1px 2px rgba(16, 24, 40, .06);
      --radius: 10px;
    }

    * {
      box-sizing: border-box;
    }

    .forecast-shell {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      color: var(--ink);
      background: var(--bg);
      line-height: 1.35;
    }

    .wrap {
      max-width: 1886px;
      margin: 18px auto;
      padding: 0 18px 28px;
    }

    .dashboard {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      overflow: hidden;
    }

    .section {
      padding: 18px 24px 14px;
      border-top: 1px solid var(--border);
      background: #fff;
      margin: inherit;
      border-radius: 10px;
    }


    .section:first-child {
      border-top: none;
    }

    .section-head {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    .section-icon {
      width: 18px;
      height: 18px;
      border-radius: 6px;
      background: rgba(23, 92, 211, .10);
      border: 1px solid rgba(23, 92, 211, .18);
      position: relative;
    }

    .section-icon:before {
      content: "";
      position: absolute;
      inset: 4px 4px 4px 4px;
      border-radius: 4px;
      background: rgba(23, 92, 211, .12);
    }

    .section-title {
      font-size: 15px;
      font-weight: 700;
      letter-spacing: .1px;
    }

    .snapshot {
      margin: 3px;
      font-size: 15px;
      color: var(--muted);
      width: 100%;
    }

    .snapshot .label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 15px;
      font-weight: 700;
      color: #344054;
      margin-bottom: 6px;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--blue);
      box-shadow: 0 0 0 3px rgba(23, 92, 211, .12);
    }

    .snapshot p {
      margin: 21px 0;
      font-size: 15px;
      color: var(--muted);
      width: 100%;
    }
.grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 22px;
    }

    .grid-2+.grid-2 {
      margin-top: 12px;
    }

    @media (max-width: 880px) {
      .grid-2 {
        grid-template-columns: 1fr;
      }
    }

    .chart-card {
      border: 1px solid var(--border);
      border-radius: 7px;
      background: #fff;
      box-shadow: var(--shadow);
      overflow: hidden;
      position: relative;
          padding: 9px;
    }

    .chart-tooltip {
      position: absolute;
      top: 0;
      left: 0;
      transform: translate(-50%, -100%);
      pointer-events: none;
      background: #F8FAFC;
      color: #0f172a;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 11px;
      line-height: 1.4;
      opacity: 0;
      transition: opacity .2s ease;
      white-space: nowrap;
      z-index: 5;
      box-shadow: 0 10px 20px rgba(15, 23, 42, .18);
    }

    .chart-tooltip strong {
      display: block;
      font-size: 12px;
      margin-bottom: 3px;
    }

    .chart-tooltip span {
      display: block;
    }

    .chart-card .card-pad {
      padding: 10px 14px 6px;
    }

    .card-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 4px;
    }

    .card-title {
      font-size: 25px;
      font-weight: 700;
      color: #344054;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .card-title .trend-ico {
      width: 14px;
      height: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .card-title .trend-ico svg {
      width: 14px;
      height: 14px;
      display: block;
      stroke: var(--blue);
      stroke-width: 2;
      fill: none;
    }

    .legend {
      display: flex;
      gap: 14px;
      align-items: center;
      font-size: 16px;
      color: var(--muted);
      white-space: nowrap;
      margin-left: auto;
    }

    .legend .litem {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend .swatch {
      width: 9px;
      height: 9px;
      border-radius: 3px;
      background: var(--blue);
    }

    .legend .swatch.orange {
      background:#FC912E;

    }

    .seg {
      display: flex;
      justify-content: center;
      gap: 16px;
      font-size: 15px;
      color: var(--muted2);
      margin: 25px 0 6px;
      user-select: none;
      margin-bottom: -32px;
      font-weight: 500;
    }

    .seg span:first-child {
      color: #344054;
      font-weight: 500;
    }

    .svg-wrap {
      padding: 2px 10px 12px;
    }

    .chart-big .card-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .chart-big .seg {
      margin-top: 2px;
    }

    .chart-big .svg-wrap {
      padding: 4px 10px 12px;
      display: flex;
      justify-content: center;
    }

    .chart-card.chart-big {
      width: calc((100% - 22px) / 2);
      margin: 14px auto;
    }

    .level-wrap {
      padding: 6px 10px 12px;
    }

    .level-chart {
      position: relative;
      width: 100%;
      height: 200px;
    }

    .level-chart.big {
      height: 230px;
    }

    .level-plot {
      position: relative;
      width: 100%;
      height: 100%;
    }

    .level-border {
      position: absolute;
      left: calc(var(--l) * 1%);
      top: calc(var(--t) * 1%);
      width: calc(var(--w) * 1%);
      height: calc(var(--h) * 1%);
      border: 1px solid var(--border);
      border-radius: 4px;
      box-sizing: border-box;
      background: #fff;
    }

    .level-grid-line {
      position: absolute;
      left: calc(var(--l) * 1%);
      width: calc(var(--w) * 1%);
      height: 1px;
      top: calc(var(--y) * 1%);
      background: var(--grid);
    }

    .level-axis-label {
      position: absolute;
      color: #9CA3AF;
      font-size: 11px;
      white-space: nowrap;
      z-index: 6;
    }

    .level-axis-label.y {
      left: calc(var(--x) * 1%);
      top: calc(var(--y) * 1%);
      transform: translate(-100%, -50%);
      text-align: right;
    }

    .level-axis-label.x {
      left: calc(var(--x) * 1%);
      top: calc(var(--y) * 1%);
      transform: translate(-50%, 0);
      text-align: center;
      line-height: 1.15;
    }

    .level-axis-label.x span {
      display: block;
    }

    .level-area {
      position: absolute;
      inset: 0;
      background: linear-gradient(180deg, rgba(129, 90, 245, 0.35) 0%, rgba(129, 90, 245, 0.06) 70%);
      pointer-events: none;
      z-index: 2;
    }

    .level-area.forecast {
      background: linear-gradient(180deg, rgba(252, 145, 46, 0.35) 0%, rgba(252, 145, 46, 0.08) 70%);
    }

    .level-line-layer {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 3;
    }

    .level-line-segment {
      position: absolute;
      height: 2px;
      background: var(--line-color, #7e5bf6);
      border-radius: 999px;
      transform-origin: 0 50%;
    }

    .level-point {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid var(--line-color, #7e5bf6);
      transform: translate(-50%, -50%);
      left: calc(var(--x) * 1%);
      top: calc(var(--y) * 1%);
      z-index: 4;
    }

    .level-hit {
      position: absolute;
      width: 14px;
      height: 14px;
      transform: translate(-50%, -50%);
      left: calc(var(--x) * 1%);
      top: calc(var(--y) * 1%);
      border-radius: 50%;
      cursor: pointer;
      z-index: 5;
    }

    @media (max-width: 880px) {
      .chart-card.chart-big {
        width: 100%;
      }
    }

    /* SVG styling */
    svg {
      width: 88%;
      height: auto;
      display: block;
    }

    .axis text {
      fill:#808080;
      font-size: 8px;
    }


    .baseline {
      stroke: #D0D7EB;
      stroke-width: 1;
    }

    .gridline {
      stroke: var(--grid);
      stroke-width: 1;
    }

    .gridline.vert {
      stroke: var(--grid);
      stroke-width: 1;
    }

    .borderline {
      stroke: #E6EAF2;
      stroke-width: 1;
      fill: none;
    }

    .line-actual {
      stroke: var(--blue);
      stroke-width: 2.3;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
    }

    .line-forecast {
      stroke: #FC912E;;
      stroke-width: 3.14;
      fill: none;
      stroke-linecap: round;
      stroke-linejoin: round;
      stroke-dasharray: 5 5;
    }

    .point {
      fill: #fff;
      stroke: var(--blue);
      stroke-width: 2;
    }

    .point.fore {
      fill: #fff;
      stroke: #FC912E;
      stroke-width: 2;
    }
.graph {
      margin-top: 18px;
    }

    .subhead-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .subhead-row .left {
      font-size: 11px;
      color: var(--muted);
      font-weight: 600;
    }

    .controls-row {
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: space-between;
      margin-bottom: 10px;
    }

    .period-filter {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
    }

    .period-filter select {
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 8px;
      font-size: 12px;
      color: var(--ink);
      background: #fff;
    }
  </style>
</head>

<body class="forecast-shell">
  <div class="wrap">
    {% if borrower_message %}
      <div class="chart-card forecast-empty">
        {% include "shared/empty_state.html" with type="noBorrower" title="Select a borrower" message=borrower_message action_label=borrower_action_label action_url=borrower_action_url %}
      </div>
    {% else %}
    <div class="dashboard">

      <!-- Liquidity Forecast -->
      <section class="section">
        <div class="section-head">
          <img src="{% static 'images/borrowing_icon.svg' %}" alt="Current Update Icon" class="current-update-icon" />
          <div class="section-title">Liquidity Forecast</div>
        </div>
        <div class="snapshot-card">
          <div class="snapshot-head">
            <img src="{% static 'images/borrowing_icon.svg' %}" alt="Snapshot Icon" class="snapshot-icon" />
            <div class="snapshot-title">
              <span>Snapshot Overview</span>
            </div>
          </div>

          {% if not forecast_snapshots.liquidity or forecast_snapshots.liquidity == snapshot_empty_message %}
            {% include "shared/empty_state.html" with type="empty" title="No snapshot summary" message="No liquidity snapshot available for this borrower yet." action_label="Add Snapshot Summary" action_url=admin_snapshot_url %}
          {% else %}
            <p class="snapshot-text">
              {{ forecast_snapshots.liquidity|linebreaksbr }}
            </p>
          {% endif %}
        </div>
    

    <div class="grid-2">
      <div class="chart-card" data-chart="availableCollateral"></div>
      <div class="chart-card" data-chart="revolverBalance"></div>
    </div>

    <div class="chart-card chart-big graph" data-chart="availableLiquidity"></div>
      </section>
    </div>

      <!-- Sales and Gross Margin Forecast -->
      <section class="section">
        <div class="section-head">
           <img src="{% static 'images/borrowing_icon.svg' %}" alt="Snapshot Icon" class="snapshot-icon" />
          <div class="section-title">Sales and Gross Margin Forecast</div>
        </div>

        <div class="snapshot">
          <div class="label"><span><img src="{% static 'images/borrowing_icon.svg' %}" alt="Snapshot Icon" class="snapshot-icon" /></span>Snapshot Overview</div>
          {% if not forecast_snapshots.sales_gm or forecast_snapshots.sales_gm == snapshot_empty_message %}
            {% include "shared/empty_state.html" with type="empty" title="No snapshot summary" message="No sales & gross margin snapshot available for this borrower yet." action_label="Add Snapshot Summary" action_url=admin_snapshot_url %}
          {% else %}
            <p>
              {{ forecast_snapshots.sales_gm|linebreaksbr }}
            </p>
          {% endif %}
        </div>

        <div class="grid-2">
          <div class="chart-card" data-chart="sales"></div>
          <div class="chart-card" data-chart="grossMargin"></div>
        </div>
      </section>

      <!-- Accounts Receivable Forecast -->
      <section class="section">
        <div class="section-head">
          <img src="{% static 'images/borrowing_icon.svg' %}" alt="Snapshot Icon" class="snapshot-icon" />
          <div class="section-title">Accounts Receivable Forecast</div>
        </div>

        <div class="snapshot">
          <div class="label"><img src="{% static 'images/borrowing_icon.svg' %}" alt="Snapshot Icon" class="snapshot-icon" />Snapshot Overview</div>
          {% if not forecast_snapshots.ar or forecast_snapshots.ar == snapshot_empty_message %}
            {% include "shared/empty_state.html" with type="empty" title="No snapshot summary" message="No accounts receivable snapshot available for this borrower yet." action_label="Add Snapshot Summary" action_url=admin_snapshot_url %}
          {% else %}
            <p>
              {{ forecast_snapshots.ar|linebreaksbr }}
            </p>
          {% endif %}
        </div>

        <div class="chart-card chart-big" data-chart="accountsReceivable"></div>
      </section>

      <!-- Inventory Forecast -->
      <section class="section">
        <div class="section-head">
          <img src="{% static 'images/borrowing_icon.svg' %}" alt="" class="snapshot-icon" />
          <div class="section-title">Inventory Forecast</div>
        </div>

        <div class="snapshot">
          <div class="label"><img src="{% static 'images/borrowing_icon.svg' %}" alt="" class="snapshot-icon" />Snapshot Overview</div>
          {% if not forecast_snapshots.inventory or forecast_snapshots.inventory == snapshot_empty_message %}
            {% include "shared/empty_state.html" with type="empty" title="No snapshot summary" message="No inventory snapshot available for this borrower yet." action_label="Add Snapshot Summary" action_url=admin_snapshot_url %}
          {% else %}
            <p>
              {{ forecast_snapshots.inventory|linebreaksbr }}
            </p>
          {% endif %}
        </div>

        <div class="grid-2">
          <div class="chart-card" data-chart="finishedGoods"></div>
          <div class="chart-card" data-chart="weeksOfSupply"></div>
        </div>

        <div class="grid-2">
          <div class="chart-card" data-chart="rawMaterials"></div>
          <div class="chart-card" data-chart="workInProcess"></div>
        </div>
      </section>
    </div>
    {% endif %}
  </div>

  <script>
    /* ------------ Lightweight inline chart renderer (SVG) ------------ */

    const BORROWER_SELECTED = {{ forecast_borrower_selected|yesno:"true,false" }};
    const HAS_FORECAST_DATA = {{ forecast_has_data|yesno:"true,false" }};
    const BORROWER_MESSAGE = "{{ borrower_message|default:''|escapejs }}";
    const BORROWER_ACTION_URL = "{{ borrower_action_url|default:''|escapejs }}";
    const BORROWER_ACTION_LABEL = "{{ borrower_action_label|default:''|escapejs }}";
    const EMPTY_ACTION_URL = "{{ admin_forecast_url|escapejs }}";
    const EMPTY_ACTION_LABEL = "Add from Admin panel";

    let parsedCharts = {};
    let parseError = null;
    try {
      parsedCharts = JSON.parse('{{ forecast_charts_json|default:"{}"|escapejs }}') || {};
    } catch (err) {
      parseError = err;
      console.error("Forecast chart data parse failed:", err);
      parsedCharts = {};
    }
    const deepClone = (obj) => obj ? JSON.parse(JSON.stringify(obj)) : obj;
    let CHARTS = parsedCharts;
    const SERVER_CHARTS = parsedCharts && Object.keys(parsedCharts).length ? deepClone(parsedCharts) : null;

    const chartEls = Array.from(document.querySelectorAll("[data-chart]"));

    function buildEmptyStateMarkup(state, opts = {}) {
      const title = opts.title ? `<div class="empty-state__title">${opts.title}</div>` : "";
      const message = opts.message ? `<div class="empty-state__message">${opts.message}</div>` : "";
      const action = opts.actionLabel && opts.actionUrl
        ? `<a class="empty-state__action" href="${opts.actionUrl}">${opts.actionLabel}</a>`
        : "";
      const skeleton = state === "loading"
        ? `<div class="empty-state__skeleton" aria-hidden="true"><span></span><span></span><span></span></div>`
        : "";
      return `
        <div class="empty-state empty-state--${state}">
          <div class="empty-state__icon" aria-hidden="true"></div>
          <div class="empty-state__body">
            ${title}
            ${message}
            ${skeleton}
            ${action}
          </div>
        </div>
      `;
    }

    function renderChartState(state, options = {}) {
      chartEls.forEach((el) => {
        el.innerHTML = buildEmptyStateMarkup(state, options);
      });
    }

    function stateConfig(state) {
      if (state === "loading") {
        return {
          title: "Loading forecast data",
          message: "Building the latest forecast view.",
        };
      }
      if (state === "noBorrower") {
        return {
          title: "Select a borrower",
          message: BORROWER_MESSAGE || "Select a borrower to view forecast data.",
          actionLabel: BORROWER_ACTION_LABEL,
          actionUrl: BORROWER_ACTION_URL,
        };
      }
      if (state === "empty") {
        return {
          title: "No forecast data",
          message: "No forecast data available for this borrower yet.",
          actionLabel: EMPTY_ACTION_LABEL,
          actionUrl: EMPTY_ACTION_URL,
        };
      }
      if (state === "error") {
        return {
          title: "Unable to load forecast data",
          message: "Please try again later.",
        };
      }
      return {};
    }

    function formatMonthLabel(dateObj) {
      const month = dateObj.toLocaleString("en-US", { month: "short" });
      return `${month} ${dateObj.getFullYear()}`;
    }

    function getMonthLabels(pastCount, futureCount) {
      const now = new Date();
      const past = [];
      for (let i = pastCount - 1; i >= 0; i--) {
        const d = new Date(now.getFullYear(), now.getMonth() - i, 1);
        past.push(formatMonthLabel(d));
      }
      const future = [];
      for (let i = 1; i <= futureCount; i++) {
        const d = new Date(now.getFullYear(), now.getMonth() + i, 1);
        future.push(formatMonthLabel(d));
      }
      return { past, future };
    }

    function sliceChart(chart, months, labelSeqPast, labelSeqFuture, pastCount, futureCount) {
      const m = Math.max(1, Math.min(months, 12));
      const actualCount = Array.isArray(chart.actual) ? chart.actual.length : 0;
      const forecastCount = Array.isArray(chart.forecast) ? chart.forecast.length : 0;
      const labels = Array.isArray(chart.labels) ? chart.labels : [];

      const past = Math.max(0, Math.min(pastCount ?? m, actualCount));
      const future = Math.max(0, Math.min(futureCount ?? m, forecastCount));
      const slicedActual = chart.actual ? chart.actual.slice(-past) : [];
      const slicedForecast = chart.forecast ? chart.forecast.slice(0, future) : [];
      const pastLabels = labelSeqPast
        ? labelSeqPast.slice(-slicedActual.length)
        : labels.slice(0, actualCount).slice(-slicedActual.length);
      const futureLabels = labelSeqFuture
        ? labelSeqFuture.slice(0, slicedForecast.length)
        : labels.slice(actualCount).slice(0, slicedForecast.length);

      const labelsCombined = [...pastLabels, ...futureLabels];

      const labelsShort =
        chart.labelsShort && chart.labelsShort.length === labelsCombined.length
          ? chart.labelsShort
          : labelsCombined;

      return {
        ...chart,
        actual: slicedActual,
        forecast: slicedForecast,
        labels: labelsCombined,
        labelsShort,
        pastLabel: `Past ${m} Months`,
        forecastLabel: `${m} Month Forecast`,
      };
    }

    function buildChartConfig(periodMonths) {
      const totalMonths = Math.max(1, Math.min(12, periodMonths));
      const pastMonths = Math.ceil(totalMonths / 2);
      const futureMonths = Math.max(1, totalMonths - pastMonths);
      const { past: pastLabels, future: futureLabels } = getMonthLabels(pastMonths, futureMonths);

      if (!SERVER_CHARTS) {
        return {};
      }
      const sliced = {};
      Object.keys(SERVER_CHARTS).forEach(key => {
        sliced[key] = sliceChart(SERVER_CHARTS[key], totalMonths, pastLabels, futureLabels, pastMonths, futureMonths);
      });
      return sliced;
    }

    function formatY(v, chart) {
      if (chart.yFormat === "pct") return `${Math.round(v)}%`;
      if (chart.yFormat === "num") return `${v.toFixed(1)}`;
      const abs = Math.abs(v);
      if (abs >= 1_000_000) {
        return `${chart.yPrefix}${(v / 1_000_000).toFixed(1)}M`;
      }
      if (abs >= 1_000) {
        return `${chart.yPrefix}${(v / 1_000).toFixed(0)}K`;
      }
      return `${chart.yPrefix}${v.toFixed(1)}`;
    }

    function linePath(points) {
      return points.map((p, i) => (i === 0 ? `M ${p[0]} ${p[1]}` : `L ${p[0]} ${p[1]}`)).join(" ");
    }

    const LEVEL_KEYS = new Set([
      "availableCollateral",
      "revolverBalance",
      "availableLiquidity",
      "sales",
      "grossMargin",
      "accountsReceivable",
      "finishedGoods",
      "weeksOfSupply",
      "rawMaterials",
      "workInProcess",
    ]);

    function renderLevelCard(el, key) {
      const cfg = CHARTS[key];
      const isBig = el.classList.contains("chart-big");

      if (!cfg || !cfg.labels?.length) {
        el.innerHTML = buildEmptyStateMarkup("empty", stateConfig("empty"));
        return;
      }

      const actual = Array.isArray(cfg.actual) ? cfg.actual : [];
      const forecast = Array.isArray(cfg.forecast) ? cfg.forecast : [];
      const total = cfg.labels.length || actual.length + forecast.length;
      const series = Array.from({ length: total }, (_, i) => {
        if (i < actual.length) return actual[i];
        const idx = i - actual.length;
        return idx < forecast.length ? forecast[idx] : null;
      });
      const values = series.filter(v => v !== null && v !== undefined);
      if (!values.length) {
        el.innerHTML = buildEmptyStateMarkup("empty", stateConfig("empty"));
        return;
      }

      let min = Math.min(...values);
      let max = Math.max(...values);
      const range = (max - min) || 1;
      min -= range * 0.12;
      max += range * 0.12;

      el.innerHTML = `
        <div class="card-pad">
          <div class="card-top">
            <div class="card-title">
             <img src="{% static 'images/borrowing_icon.svg' %}"
          alt="Current Update Icon"
          class="current-update-icon" />
              ${cfg.title}
            </div>
            <div class="legend" aria-label="legend">
              <div class="litem"><span class="swatch"></span>${cfg.pastLabel || "Actual"}</div>
              <div class="litem"><span class="swatch orange"></span>${cfg.forecastLabel || "Forecast"}</div>
            </div>
          </div>
          <div class="seg"><span>${cfg.pastLabel || "Actual"}</span><span>${cfg.forecastLabel || "Forecast"}</span></div>
        </div>
        <div class="level-wrap">
          <div class="level-chart ${isBig ? "big" : ""}">
            <div class="level-plot"></div>
          </div>
        </div>
      `;

      const plot = el.querySelector(".level-plot");
      const tooltip = document.createElement("div");
      tooltip.className = "chart-tooltip";
      el.appendChild(tooltip);

      const buildMarkup = () => {
        const rect = plot.getBoundingClientRect();
        const width = rect.width;
        const height = rect.height;
        if (!width || !height) return;

        const pad = {
          l: Math.max(40, Math.round(width * 0.09)),
          r: Math.max(16, Math.round(width * 0.04)),
          t: Math.max(14, Math.round(height * 0.06)),
          b: Math.max(34, Math.round(height * 0.2)),
        };
        const plotW = Math.max(1, width - pad.l - pad.r);
        const plotH = Math.max(1, height - pad.t - pad.b);
        const plotLeftPct = (pad.l / width) * 100;
        const plotTopPct = (pad.t / height) * 100;
        const plotWPct = (plotW / width) * 100;
        const plotHPct = (plotH / height) * 100;

        const denom = Math.max(1, total - 1);
        const xPx = (i) => pad.l + (i / denom) * plotW;
        const yPx = (v) => pad.t + (1 - (v - min) / (max - min)) * plotH;
        const xPct = (i) => (xPx(i) / width) * 100;
        const yPct = (v) => (yPx(v) / height) * 100;

        const points = series.map((v, i) => {
          if (v === null || v === undefined) return null;
          return {
            index: i,
            value: v,
            label: cfg.labels[i] || "",
            x: xPx(i),
            y: yPx(v),
            xp: xPct(i),
            yp: yPct(v),
          };
        });

        const forecastPoints = Array.from({ length: total }, (_, i) => {
          if (i < actual.length) return null;
          const idx = i - actual.length;
          if (idx < forecast.length) {
            const v = forecast[idx];
            return {
              x: xPx(i),
              y: yPx(v),
            };
          }
          return null;
        });

        const ticks = cfg.yTicks || 5;
        const yTicks = Array.from({ length: ticks }, (_, i) => {
          const t = i / (ticks - 1);
          const val = max - t * (max - min);
          return { val, yp: yPct(val) };
        });

        let xLabelStep = 1;
        if (total > 12) xLabelStep = 2;
        if (total > 24) xLabelStep = 3;
        const xTickIndices = cfg.labels.map((_, i) => i).filter(i => i % xLabelStep === 0);

        const xLabelTopPx = pad.t + plotH + Math.max(12, height * 0.05);
        const xLabelTopPct = (xLabelTopPx / height) * 100;

        const grid = yTicks.map(t => `
          <div class="level-grid-line" style="--l:${plotLeftPct}; --w:${plotWPct}; --y:${t.yp};"></div>
          <div class="level-axis-label y" style="left:${plotLeftPct - 1}%; top:${t.yp}%;">${formatY(t.val, cfg)}</div>
        `).join("");

        const verticalGrid = xTickIndices.map(i => `
          <div class="level-grid-line" style="left:${xPct(i)}%; top:${plotTopPct}%; width:1px; height:${plotHPct}%;"></div>
        `).join("");

        const xLabels = xTickIndices.map(i => {
          const shortLab = (cfg.labelsShort && cfg.labelsShort[i]) || cfg.labels[i] || "";
          const parts = shortLab.split(" ");
          const line1 = parts.slice(0, parts.length - 1).join(" ") || shortLab;
          const line2 = parts[parts.length - 1] || "";
          return `
            <div class="level-axis-label x" style="left:${xPct(i)}%; top:${xLabelTopPct}%;">
              <span>${line1}</span>
              <span>${line2}</span>
            </div>
          `;
        }).join("");

        const areaPoints = points.filter(Boolean);
        const actualArea = areaPoints.filter(p => p.index < actual.length);
        const forecastArea = areaPoints.filter(p => p.index >= actual.length);
        const areaBottomPct = (pad.t + plotH) / height * 100;
        const buildAreaClip = (pts) => {
          if (!pts.length) return "none";
          return `polygon(${pts.map(p => `${p.xp}% ${p.yp}%`).join(", ")}, ${pts[pts.length - 1].xp}% ${areaBottomPct}%, ${pts[0].xp}% ${areaBottomPct}%)`;
        };
        const actualClip = buildAreaClip(actualArea);
        let forecastAreaPoints = forecastArea;
        if (forecastArea.length && actualArea.length) {
          forecastAreaPoints = [actualArea[actualArea.length - 1], ...forecastArea];
        }
        const forecastClip = buildAreaClip(forecastAreaPoints);

        const buildSegments = (pts, color) => {
          let html = "";
          for (let i = 1; i < pts.length; i++) {
            const prev = pts[i - 1];
            const curr = pts[i];
            if (!prev || !curr) continue;
            const dx = curr.x - prev.x;
            const dy = curr.y - prev.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            html += `
              <div class="level-line-segment" style="left:${prev.x}px; top:${prev.y}px; width:${length}px; transform:rotate(${angle}rad); --line-color:${color};"></div>
            `;
          }
          return html;
        };

        const mainSegments = buildSegments(points, "#7e5bf6");
        const forecastSegments = buildSegments(forecastPoints, "#FC912E");

        const pointDots = points.map(point => {
          if (!point) return "";
          return `<div class="level-point" style="left:${point.xp}%; top:${point.yp}%; --line-color:#7e5bf6;"></div>`;
        }).join("");

        const hits = points.map(point => {
          if (!point) return "";
          return `<div class="level-hit" data-index="${point.index}" style="left:${point.xp}%; top:${point.yp}%;"></div>`;
        }).join("");

        plot.innerHTML = `
          <div class="level-border" style="--l:${plotLeftPct}; --t:${plotTopPct}; --w:${plotWPct}; --h:${plotHPct};"></div>
          ${grid}
          ${verticalGrid}
          ${xLabels}
          <div class="level-area actual" style="clip-path:${actualClip};"></div>
          <div class="level-area forecast" style="clip-path:${forecastClip};"></div>
          <div class="level-line-layer level-main">${mainSegments}</div>
          <div class="level-line-layer level-comp">${forecastSegments}</div>
          ${pointDots}
          ${hits}
        `;
      };

      buildMarkup();

      plot.addEventListener("mousemove", (event) => {
        const hit = event.target.closest(".level-hit");
        if (!hit) {
          tooltip.style.opacity = "0";
          return;
        }
        const index = parseInt(hit.dataset.index, 10);
        if (Number.isNaN(index)) return;
        const label = cfg.labels[index] || "Point";
        const actualValue = index < actual.length ? actual[index] : null;
        const forecastIndex = index - actual.length;
        const forecastValue =
          forecastIndex >= 0 && forecastIndex < forecast.length ? forecast[forecastIndex] : null;
        const parts = [`<strong>${label}</strong>`];
        if (actualValue !== null && actualValue !== undefined) {
          parts.push(`<span>${cfg.pastLabel || "Actual"}: ${formatY(actualValue, cfg)}</span>`);
        }
        if (forecastValue !== null && forecastValue !== undefined) {
          parts.push(`<span>${cfg.forecastLabel || "Forecast"}: ${formatY(forecastValue, cfg)}</span>`);
        }
        tooltip.innerHTML = parts.join("");
        const cardRect = el.getBoundingClientRect();
        tooltip.style.left = `${event.clientX - cardRect.left}px`;
        tooltip.style.top = `${event.clientY - cardRect.top - 10}px`;
        tooltip.style.opacity = "1";
      });

      plot.addEventListener("mouseleave", () => {
        tooltip.style.opacity = "0";
      });

      if (el._levelObserver) {
        el._levelObserver.disconnect();
      }
      el._levelObserver = new ResizeObserver(() => buildMarkup());
      el._levelObserver.observe(plot);
    }

    function renderCard(el, key) {
      const cfg = CHARTS[key];
      const isBig = el.classList.contains("chart-big");
      const H = 168;
      const W = 520; // internal viewBox width (responsive)
      const pad = { l: 52, r: 18, t: 20, b: 44 };

      // compute min/max across all values with gentle padding
      if (!cfg || !cfg.labels?.length) {
        el.innerHTML = buildEmptyStateMarkup("empty", stateConfig("empty"));
        return;
      }

      const all = [...(cfg.actual || []), ...(cfg.forecast || [])];
      if (!all.length) {
        el.innerHTML = buildEmptyStateMarkup("empty", stateConfig("empty"));
        return;
      }
      let min = Math.min(...all);
      let max = Math.max(...all);
      const range = (max - min) || 1;
      min = min - range * 0.15;
      max = max + range * 0.15;

      const plotW = W - pad.l - pad.r;
      const plotH = H - pad.t - pad.b;

      const nTotal = cfg.labels.length;
      const nActual = cfg.actual.length;
      const denom = Math.max(1, nTotal - 1);
      const x = (i) => pad.l + (i / denom) * plotW;
      const y = (v) => pad.t + (1 - (v - min) / (max - min)) * plotH;

      // points
      const actualPts = (cfg.actual || []).map((v, i) => [x(i), y(v)]);
      const forecastPts = (cfg.forecast || []).map((v, j) => {
        const i = (nActual - 1) + j; // forecast begins at last actual point
        return [x(i), y(v)];
      });

      // y ticks
      const ticks = cfg.yTicks || 5;
      const yTicks = Array.from({ length: ticks }, (_, i) => {
        const t = i / (ticks - 1);
        const val = max - t * (max - min);
        return { val, y: y(val) };
      });

      // x labels (reduce density as labels grow)
      let xLabelStep = 1;
      if (nTotal > 12) xLabelStep = 2;
      if (nTotal > 24) xLabelStep = 3;
      const xTickIndices = cfg.labels.map((_, i) => i).filter(i => i % xLabelStep === 0);

      // card shell (HTML)
      el.innerHTML = `
        <div class="card-pad">
          <div class="card-top">
            <div class="card-title">
             <img src="{% static 'images/borrowing_icon.svg' %}" 
          alt="Current Update Icon"
          class="current-update-icon" />
              ${cfg.title}
            </div>
            <div class="legend" aria-label="legend">
              <div class="litem"><span class="swatch"></span>Actual</div>
              <div class="litem"><span class="swatch orange"></span>forecast</div>
            </div>
          </div>
          <div class="seg"><span>${cfg.pastLabel}</span><span>${cfg.forecastLabel}</span></div>
        </div>
        <div class="svg-wrap">
            <svg viewBox="0 0 ${W} ${H}" role="img" aria-label="${cfg.title} chart">
            <!-- plot border -->
            <rect x="${pad.l}" y="${pad.t}" width="${plotW}" height="${plotH}" class="borderline" />
            <!-- grid + y labels -->
            ${yTicks.map(t => `
              <line x1="${pad.l}" y1="${t.y}" x2="${W - pad.r}" y2="${t.y}" class="gridline" />
              <g class="axis">
                <text x="${pad.l - 8}" y="${t.y + 3}" text-anchor="end">${formatY(t.val, cfg)}</text>
              </g>
            `).join("")}
            <!-- vertical grid -->
            ${xTickIndices.map(i => `
              <line x1="${x(i)}" y1="${pad.t}" x2="${x(i)}" y2="${H - pad.b}" class="gridline vert" />
            `).join("")}
            <!-- y axis label -->
            <text x="${pad.l - 30}" y="${pad.t - 4}" text-anchor="middle" transform="rotate(-90 ${pad.l - 30} ${pad.t - 4})" font-size="10" fill="#98A2B3"></text>
            <!-- x labels -->
            <line x1="${pad.l}" y1="${H - pad.b}" x2="${W - pad.r}" y2="${H - pad.b}" class="baseline" />
            <g class="axis">
              ${cfg.labels.map((lab, i) => {
        if (i % xLabelStep !== 0) return "";
        const xx = x(i);
        if (i > 0 && lab === cfg.labels[i - 1]) return "";
        const shortLab = (cfg.labelsShort && cfg.labelsShort[i]) || lab;
        const parts = shortLab.split(" ");
        const line1 = parts.slice(0, parts.length - 1).join(" ") || shortLab;
        const line2 = parts[parts.length - 1] || "";
        const baseY = H - (isBig ? 26 : 24);
        return `<text x="${xx}" y="${baseY}" text-anchor="middle" fill="#9CA3AF" font-size="11">
                  <tspan x="${xx}" dy="0">${line1}</tspan>
                  <tspan x="${xx}" dy="10">${line2}</tspan>
                </text>`;
      }).join("")}
            </g>
            <!-- lines -->
            ${actualPts.length ? `<path d="${linePath(actualPts)}" class="line-actual" />` : ""}
            ${forecastPts.length ? `<path d="${linePath(actualPts.length ? [actualPts[actualPts.length - 1], ...forecastPts] : forecastPts)}" class="line-forecast" />` : ""}
            <!-- points (subtle like the reference) -->
            ${actualPts.map((p, i) => i === 0 || i === actualPts.length - 1 ? "" :
        `<circle cx="${p[0]}" cy="${p[1]}" r="2.2" class="point" />`
      ).join("")}
          </svg>
        </div>
      `;

      const tooltip = document.createElement("div");
      tooltip.className = "chart-tooltip";
      el.appendChild(tooltip);

      const svgEl = el.querySelector("svg");
      if (svgEl) {
        const totalPoints = cfg.labels.length;
        const actualCount = (cfg.actual || []).length;
        svgEl.addEventListener("mousemove", (event) => {
          const rect = svgEl.getBoundingClientRect();
          const cardRect = el.getBoundingClientRect();
          const xPos = Math.max(pad.l, Math.min(rect.width - pad.r, event.clientX - rect.left));
          const frac = (xPos - pad.l) / plotW;
          const clampedFrac = Math.max(0, Math.min(1, frac));
          const index = Math.round(clampedFrac * (totalPoints - 1));
          const label = cfg.labels[index] || "";
          const actualValue = index < actualCount ? cfg.actual[index] : null;
          const splitIndex = Math.max(0, actualCount - 1);
          const forecastIndex = index - splitIndex;
          const forecastValue =
            forecastIndex >= 0 && forecastIndex < cfg.forecast.length
              ? cfg.forecast[forecastIndex]
              : null;
          const parts = [`<strong>${label || "Point"}</strong>`];
          if (actualValue !== null && actualValue !== undefined) {
            parts.push(`<span>Actual: ${formatY(actualValue, cfg)}</span>`);
          }
          if (forecastValue !== null && forecastValue !== undefined) {
            parts.push(`<span>Forecast: ${formatY(forecastValue, cfg)}</span>`);
          }
          tooltip.innerHTML = parts.join("");
          tooltip.style.left = `${event.clientX - cardRect.left}px`;
          tooltip.style.top = `${event.clientY - cardRect.top - 10}px`;
          tooltip.style.opacity = parts.length > 1 ? "1" : "0";
        });
        svgEl.addEventListener("mouseleave", () => {
          tooltip.style.opacity = "0";
        });
      }
    }

    function init() {
      chartEls.forEach(el => {
        const key = el.getAttribute("data-chart");
        if (!CHARTS || !CHARTS[key]) {
          el.innerHTML = buildEmptyStateMarkup("empty", stateConfig("empty"));
          return;
        }
        if (LEVEL_KEYS.has(key)) {
          renderLevelCard(el, key);
        } else {
          renderCard(el, key);
        }
      });
    }

    function rebuild(period) {
      CHARTS = buildChartConfig(period);
      init();
    }

    function bootCharts() {
      renderChartState("loading", stateConfig("loading"));
      let state = "ok";
      if (parseError) {
        state = "error";
      } else if (!BORROWER_SELECTED) {
        state = "noBorrower";
      } else if (!HAS_FORECAST_DATA) {
        state = "empty";
      }
      if (state !== "ok") {
        renderChartState(state, stateConfig(state));
        return;
      }
      try {
        CHARTS = buildChartConfig(12);
        init();
      } catch (err) {
        console.error("Forecast chart render failed:", err);
        renderChartState("error", stateConfig("error"));
      }
    }

    // initial render
    bootCharts();

    // period selector (fallback only when server data not provided)
    const periodSelect = document.getElementById("period-select");
    if (periodSelect && BORROWER_SELECTED && HAS_FORECAST_DATA && !parseError) {
      periodSelect.addEventListener("change", function () {
        const months = parseInt(this.value, 10) || 12;
        rebuild(months);
      });
    }
  </script>
</body>

</html>

{% endblock %}
